#################################################################################################### 
ğŸ›¡ï¸ RESILIENT STEGANOGRAPHY IN RUST Implementation of Cryptographic Chaining & Plausible Deniability 
####################################################################################################

ğŸš€ PROJECT OVERVIEW
This is a high-performance steganographic CLI tool designed for "Plausible Deniability". Unlike traditional tools that hide a file inside a single image, this solution fragments encrypted data across a chain of multiple images, interspersed with mathematically indistinguishable "decoys".

Language: Rust ğŸ¦€ Encryption: AES-256-GCM Method: LSB (Least Significant Bit) with Linked List Chaining 


ğŸŒŸ KEY FEATURES
ğŸ”’ AUTHENTICATED ENCRYPTION Uses AES-256-GCM. Confidentiality is useless without integrity; if an image is corrupted or tampered with, the system rejects it immediately.

ğŸ”— CHAINING PROTOCOL (THE "GHOST" LINKED LIST) Large files are sliced into chunks. Each image contains a hidden encrypted header pointing to the filename of the next image. â€¢ The file names are random (e.g., "a7x9.png" -> "b2k1.png"). â€¢ No visual or sequential pattern exists in the folder.


ğŸ­ DECOY OBFUSCATION Fills the folder with "fake" images containing cryptographic noise. â€¢ Real Data = Max Entropy (Encrypted). â€¢ Decoys = Max Entropy (Random Noise). â€¢ Result: Forensic tools cannot statistically distinguish real files from fake ones.


ğŸ•µï¸ ANTI-FORENSICS (METADATA WIPING) â€¢ Scrambles file creation order physically on the disk. â€¢ Sanitizes "Last Modified" timestamps to destroy chronological evidence.


ğŸ› ï¸ INSTALLATION
Prerequisites: Rust (Cargo) installed.

$ git clone https://github.com/yugi386/steganography $ cd steganography $ cargo build --release

The binary will be generated at: ./target/release/esteganografia

ğŸ’» USAGE GUIDE
[ 1 ] HIDE DATA (CREATE THE CHAIN) ğŸ“¥ Compresses, encrypts, and spreads a file across a pool of images. It uses "Infinite Recycling" (reuses source images if needed).

  $ ./target/release/esteganografia hide \
      --input-dir "./clean_images" \
      --file "./secret.pdf" \
      --output-dir "./output_folder" \
      --password "YourStrongPass" \
      --bits 2
[ 2 ] GENERATE DECOYS (MAKE IT NOISY) ğŸ­ Floods the folder with fake files to hide the real chain. Crucial for Plausible Deniability.

  $ ./target/release/esteganografia decoys \
      --input-dir "./clean_images" \
      --output-dir "./output_folder" \
      --bits 2
[ 3 ] SCAN & RECOVER (FIND THE NEEDLE) ğŸ“¡ If you have a folder with 1000 random images and don't know where the chain starts, this mode attempts to decrypt headers until it finds "Sequence: 0".

  $ ./target/release/esteganografia scan \
      --dir "./output_folder" \
      --password "YourStrongPass"
[ 4 ] DIRECT RECOVERY ğŸ“¤ If you already know the starting filename.

  $ ./target/release/esteganografia recover \
      --input-img "./output_folder/start_file.png" \
      --password "YourStrongPass"
âš™ï¸ TECHNICAL ARCHITECTURE
The core logic relies on the "ChainHeader" struct embedded in every image:

struct ChainHeader {
    chunk_len: u32,        // Size of data in this image
    has_next: bool,        // Is there another link?
    next_filename: String, // Pointer to the next image
    sequence_number: u32,  // Anti-reordering protection
}
âš ï¸ DISCLAIMER
This software is a Proof of Concept (PoC) for academic research regarding Anti-Forensics and Privacy. The authors are not responsible for illicit usage.

ğŸ“š REFERENCES
Based on the paper: "Resilient Steganography in Rust" by Edimar VerÃ­ssimo da Silva. Code Source: https://github.com/yugi386/steganography.
